---
title: 蓝牙传输基础
date: 2019-09-06 11:25:07
tags: ['Android']
---
## 蓝牙数据传输基础
Android蓝牙中涉及通用数据传输协议的有两种：

* SPP协议  
  SPP协议是Android 2.0引入的API，是通过Socket的形式来实现数据传输及交互，有分客户端和服务端，手机一般以客户端的角色主动连接SPP协议设备，也就是经典蓝牙。

* BLE(Bluetooth low energy)协议  
  BLE协议是Android 4.3引入的API，但手机厂商大部份在Android 4.4上才支持BLE，即低功耗蓝牙，一般我们开发的话是使用中央（BluetoothGatt）或者外围（BluetoothGattServer）来进行开发的，手机正常情况下当作中央设备来接收信息，而蓝牙模块当作是外围设备发送数据。

## SPP 协议

## BLE 协议

## 重要成员和概念
The following is a summary of key BLE terms and concepts:

+ Generic Attribute Profile (GATT)
The GATT profile is a general specification for sending and receiving short pieces of data known as "attributes" over a BLE link. All current BLE application profiles are based on GATT. Review the Android BluetoothLeGatt sample on GitHub to learn more.

+ Profiles
The Bluetooth SIG defines many profiles for BLE devices. A profile is a specification for how a device works in a particular application. Note that a device can implement more than one profile. For example, a device could contain a heart rate monitor and a battery level detector.

+ Attribute Protocol (ATT)
GATT is built on top of the Attribute Protocol (ATT). This is also referred to as GATT/ATT. ATT is optimized to run on BLE devices. To this end, it uses as few bytes as possible. Each attribute is uniquely identified by a Universally Unique Identifier (UUID), which is a standardized 128-bit format for a string ID used to uniquely identify information. The attributes transported by ATT are formatted as characteristics and services.

+ Characteristic
A characteristic contains a single value and 0-n descriptors that describe the characteristic's value. A characteristic can be thought of as a type, analogous to a class.

+ Descriptor
Descriptors are defined attributes that describe a characteristic value. For example, a descriptor might specify a human-readable description, an acceptable range for a characteristic's value, or a unit of measure that is specific to a characteristic's value.

+ Service
A service is a collection of characteristics. For example, you could have a service called "Heart Rate Monitor" that includes characteristics such as "heart rate measurement." You can find a list of existing GATT-based profiles and services on bluetooth.org.

## 用法
### 权限
和经典蓝牙一样，使用低功耗蓝牙，需要声明BLUETOOTH权限，如果需要扫描设备或者操作蓝牙设置，则还需要BLUETOOTH_ADMIN权限：
```
  <uses-permission android:name="android.permission.BLUETOOTH"/>
  <uses-permission android:name="android.permission.BLUETOOTH_ADMIN"/>

  <uses-feature android:name="android.hardware.bluetooth_le" android:required="true"/>
```
当required为true时，则应用只能在支持BLE的Android设备上安装运行；required为false时，Android设备均可正常安装运行，需要在代码中判断设备是否支持BLE feature：
```
    if(!getPackageManager().hasSystemFeature(PackageManager.  FEATURE_BLUETOOTH_LE)) {
      Toast.makeText(this, R.string.ble_not_supported, Toast.LENGTH_SHORT).show();
      finish();
    }
```
### 获取 BluetoothAdapter
所有的蓝牙活动都需要 BluetoothAdapter, BluetoothAdapter 代表了设备本身的蓝牙适配器 (蓝牙无线设备). 整个系统中只有一个 蓝牙适配器, 应用可以使用 BluetoothAdapter 对象与 蓝牙适配器硬件进行交互.
```

    // Initializes a Bluetooth adapter.  For API level 18 and above, get a reference to
    // BluetoothAdapter through BluetoothManager.
    final BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
    mBluetoothAdapter = bluetoothManager.getAdapter();
```

为了保证 蓝牙功能是打开的, 调用 BluetoothAdapter 的 isEnable() 方法, 检查蓝牙在当前是否可用. 如果返回 false, 说明当前蓝牙不可用.
```

    // 确认当前设备的蓝牙是否可用,   
    // 如果不可用, 弹出一个对话框, 请求打开设备的蓝牙模块  
    if (mBluetoothAdapter == null || !mBluetoothAdapter.isEnabled()) {  
        Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);  
        startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);  
    }  
```

### 查找设备

搜索 BLE 设备, 调用 BluetoothAdapter 的 startLeScan() 方法, 该方法需要一个 BluetoothAdapter.LeScanCallback 类型的参数. 你必须实现这个 LeScanCallback 接口, 因为 BLE 蓝牙设备扫描结果在这个接口中返回.蓝牙搜索是一个耗电的操作，因此蓝牙搜索提供了两种搜索模式：
中断搜索：一搜索到设备就中断搜索
不循环搜索：给搜索设置一个合适的扫描周期

扫描设备：
```

    private void scanLeDevice(final boolean enable) {
        if (enable) {
            // Stops scanning after a pre-defined scan period.
            mHandler.postDelayed(new Runnable() {

                public void run() {
                    isScanned = false;
                    refreshLayout.setRefreshing(false);
                    mBluetoothAdapter.stopLeScan(mLeScanCallback);
                }
            }, SCAN_PERIOD);

            isScanned = true;
            mBluetoothAdapter.startLeScan(mLeScanCallback);
        } else {
            if (refreshLayout.isRefreshing()){
                refreshLayout.setRefreshing(false);
            }
            isScanned = false;
            mBluetoothAdapter.stopLeScan(mLeScanCallback);
        }
    }
```

回调代码：
```

    private final LeScanCallback mLeScanCallback = new LeScanCallback() {

        public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) {
            runOnUiThread(new Runnable() {
                public void run() {
                    if (!devices.contains(device)){
                        devices.add(device);
                        adapter.notifyDataSetChanged();
                    }

                }
            });
        }
    };
```

### 查找特定设备

查找特定类型的外围设备, 可以调用下面的方法, 这个方法需要提供一个 UUID 对象数组, 这个 UUID 数组是 APP 支持的 GATT 服务的特殊标识.
```
startLeScan(UUID[], BluetoothAdapter.LeScanCallback)
```

### 连接到GATT服务
调用 BluetoothDevice 的 connectGatt() 方法可以连接到 BLE 设备的 GATT 服务. 参数一 Context 上下文对象, 参数二 boolean autoConnect 是否自动连接扫描到的蓝牙设备, 参数三 BluetoothGattCallback 接口实现类.
```

    mBluetoothGatt = device.connectGatt(this, false, mGattCallback);
```

### GATT数据交互

这段代码的本质就是 BLE 设备的 GATT 服务 与 Android 的 BLE API 进行交流. 当一个特定的回调被触发, 它调用适当的 broadcastUpdate() 帮助方法, 将其当做一个 Action 操作传递出去.
```

    /**
      * Implements callback methods for GATT events that the app cares about.
      * For example,connection change and services discovered.
      */
    private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {
        @Override
        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
            String intentAction;
            if (newState == BluetoothProfile.STATE_CONNECTED) {
                intentAction = ACTION_GATT_CONNECTED;
                broadcastUpdate(intentAction);
                Log.i(TAG, "Connected to GATT server.");
                // Attempts to discover services after successful connection.
                Log.i(TAG, "Attempting to start service discovery:" + mBluetoothGatt.discoverServices());

            } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
                intentAction = ACTION_GATT_DISCONNECTED;
                Log.i(TAG, "Disconnected from GATT server.");
                broadcastUpdate(intentAction);
            } else if(newState == BluetoothProfile.STATE_CONNECTING){
                intentAction = ACTION_GATT_CONNECTING;
                Log.i(TAG, "connecting from GATT server.");
                broadcastUpdate(intentAction);
            } else {
                intentAction = ACTION_GATT_DISCONNECTING;
                Log.i(TAG, "Disconnecting from GATT server.");
                broadcastUpdate(intentAction);
            }
        }

    private void broadcastUpdate(final String action) {
      final Intent intent = new Intent(action);
      sendBroadcast(intent);
    }
```

### 读取 BLE 属性
到了这里我就要详细的讲解一下BLE GATT PROFILE的组织结构了。每个蓝牙设备都有一个Profile（就把这个Profile想象成是一个蓝牙模块），每个Profile有多个service（服务）如电量信息服务、系统信息服务等，每个service有多个Characteristic（特征），每个特征里面包括属性（properties）和值（value）和若干个descriptor（描述符）。我们刚才提到的service和characteristic，都需要一个唯一的uuid来标识，如图：

Android 应用连接到了设备中的 GATT 服务, 并且发现了各种服务 (特征集合), 可以读写其中的属性,遍历服务 (特征集合) 和 特征, 将其展示在 UI 界面中.
```

    // 遍历 GATT 服务  
    for (BluetoothGattService gattService : gattServices) {  
      HashMap<String, String> currentServiceData =  
              new HashMap<String, String>();  
      uuid = gattService.getUuid().toString();  
      currentServiceData.put(  
              LIST_NAME, SampleGattAttributes.  
                      lookup(uuid, unknownServiceString));  
      currentServiceData.put(LIST_UUID, uuid);  
      gattServiceData.add(currentServiceData);  

      ArrayList<HashMap<String, String>> gattCharacteristicGroupData =  
              new ArrayList<HashMap<String, String>>();  
                
      // 获取服务中的特征集合  
      List<BluetoothGattCharacteristic> gattCharacteristics =  
              gattService.getCharacteristics();  
      ArrayList<BluetoothGattCharacteristic> charas =  
              new ArrayList<BluetoothGattCharacteristic>();  
                
      // 循环遍历特征集合  
      for (BluetoothGattCharacteristic gattCharacteristic :  
              gattCharacteristics) {  
          charas.add(gattCharacteristic);  
          HashMap<String, String> currentCharaData =  
                  new HashMap<String, String>();  
          uuid = gattCharacteristic.getUuid().toString();  
          currentCharaData.put(  
                  LIST_NAME, SampleGattAttributes.lookup(uuid,  
                          unknownCharaString));  
          currentCharaData.put(LIST_UUID, uuid);  
          gattCharacteristicGroupData.add(currentCharaData);  
      }  
      mGattCharacteristics.add(charas);  
      gattCharacteristicData.add(gattCharacteristicGroupData);  
    }  
```

### 接收GATT通知

当 BLE 设备中的一些特殊的特征改变, 需要通知与之连接的 Android BLE 应用，使用 setCharacteristicNotification() 方法为特征设置通知.
```

    private BluetoothGatt mBluetoothGatt;  
    BluetoothGattCharacteristic characteristic;  
    boolean enabled;  
      
    // 设置是否监听某个特征改变  
    mBluetoothGatt.setCharacteristicNotification(characteristic, enabled);  
      
    BluetoothGattDescriptor descriptor = characteristic.getDescriptor(  
            UUID.fromString(SampleGattAttributes.CLIENT_CHARACTERISTIC_CONFIG));  
    descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);  
    mBluetoothGatt.writeDescriptor(descriptor);  
    一旦特征开启了改变通知监听, 如果特性发生了改变, 就会回调 BluetoothGattCallback 接口中的 onCharacteristicChanged() 方法.

    @Override  
    // 特性通知  
    public void onCharacteristicChanged(BluetoothGatt gatt,  
            BluetoothGattCharacteristic characteristic) {  
        broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic);  
    }  
```

### 关闭APP中的BLE连接

一旦结束了 BLE 设备的使用, 调用 BluetoothGatt 的 close() 方法, 关闭 BLE 连接, 释放相关的资源.
```

    public void close() {  
        if (mBluetoothGatt == null) {  
            return;  
        }  
        mBluetoothGatt.close();  
        mBluetoothGatt = null;  
    }
```
